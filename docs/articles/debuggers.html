<!DOCTYPE html><meta charset=utf-8 ><meta name=viewport  content="width=device-width,initial-scale=1"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital@0;1&display=swap" rel=stylesheet ><title>Debuggers - how they work and how to make one on Linux</title><style>@charset "utf-8";html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}table{border-collapse:collapse;border-spacing:0}body{background:#fafafa;font-family:'IBM Plex Serif',serif;font-size:20px}nav{display:flex;background:#171717;color:white;z-index:1;position:relative;align-items:center;justify-content:space-between}nav>div{display:flex}nav h1{margin:0 8px;font-size:28px;line-height:1.6}nav p{margin:0 12px 0 6px}nav h1,nav p{cursor:pointer}nav h1:hover,nav p:hover{text-decoration:underline}nav a{color:inherit;text-decoration:inherit}a{color:#29B6F6}.titledate{text-align:center;background:#222;color:white;padding:32px;margin-bottom:10px;box-shadow:0 0 8px #444}.title,.author{margin-bottom:18px;font-size:22px}.title{font-size:34px}.date{color:gray;font-style:italic}article{padding:32px;line-height:1.3;margin:0 auto;max-width:1200px}@media only screen and (max-width:700px){article{padding:12px}}h2,h3{font-size:32px;font-weight:bold;padding:32px 0}h3{font-size:24px;padding:16px 0}article .standard{padding:4px 0}table{margin:4px auto}td{padding:4px 6px;border:1px black solid}ul{list-style-type:disc}ol{list-style-type:decimal}ul ul,ul ol,ol ol,ol ul{padding-left:32px}li::before{content:"";display:inline-block;width:8px}@charset "utf-8"; .highlight pre{font-family:monospace;background:#fdfdfd;border:#aaa 1px solid;padding:8px;margin:8px 0;border-radius:4px;white-space:pre-wrap}.highlight .hll{background-color:#ffc}.highlight .c{color:#998;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{color:#000;font-weight:bold}.highlight .o{color:#000;font-weight:bold}.highlight .cm{color:#998;font-style:italic}.highlight .cp{color:#999;font-weight:bold;font-style:italic}.highlight .c1{color:#998;font-style:italic}.highlight .cs{color:#999;font-weight:bold;font-style:italic}.highlight .gd{color:#000;background-color:#fdd}.highlight .ge{color:#000;font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000;background-color:#dfd}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{color:#000;font-weight:bold}.highlight .kd{color:#000;font-weight:bold}.highlight .kn{color:#000;font-weight:bold}.highlight .kp{color:#000;font-weight:bold}.highlight .kr{color:#000;font-weight:bold}.highlight .kt{color:#458;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d01040}.highlight .na{color:#008080}.highlight .nb{color:#0086B3}.highlight .nc{color:#458;font-weight:bold}.highlight .no{color:#008080}.highlight .nd{color:#3c5d5d;font-weight:bold}.highlight .ni{color:#800080}.highlight .ne{color:#900;font-weight:bold}.highlight .nf{color:#900;font-weight:bold}.highlight .nl{color:#900;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:#000080}.highlight .nv{color:#008080}.highlight .ow{color:#000;font-weight:bold}.highlight .w{color:#bbb}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .mi{color:#099}.highlight .mo{color:#099}.highlight .sb{color:#d01040}.highlight .sc{color:#d01040}.highlight .sd{color:#d01040}.highlight .s2{color:#d01040}.highlight .se{color:#d01040}.highlight .sh{color:#d01040}.highlight .si{color:#d01040}.highlight .sx{color:#d01040}.highlight .sr{color:#009926}.highlight .s1{color:#d01040}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc{color:#008080}.highlight .vg{color:#008080}.highlight .vi{color:#008080}.highlight .il{color:#099}</style><nav><h1><a href="/">Misha's blog</a></h1><div><p><a href="/articles">Articles</a></p><p><a href="/about">About</a></p></div></nav><div class=titledate ><h1 class=title  id='magicparlabel-1'>Debuggers - how they work and how to make one on Linux</h1> <div class=date  id='magicparlabel-2'>July 20, 2021</div> </div class="titledate"><article><div class=standard  id='magicparlabel-3'>Debuggers are like magic. You can take a program and see what cards it is holding, change the cards of the program without it seeing anything, and put a bunny into its hat.</div> <div class=standard  id='magicparlabel-4'>It's impolite to ask how magic works, but deep inside, you ask yourself, how do debuggers work? Don't processes run directly on the CPU and thus can't be stopped at breakpoints or single-steps? And reading another process's memory and registers, isn't this something users can't do?</div> <h2 class=section_  id='magicparlabel-5'>The abstract</h2> <div class=standard  id='magicparlabel-6'>Though there are hardware breakpoints (which are stored in 8 registers on x86), this feels like cheating, and they're also very limited in number. Software breakpoints are much more interesting.</div> <div class=standard  id='magicparlabel-7'>To stop the execution of the program and hand over control to the kernel, we must have some sort of interrupt or system-call. Interrupt 3 is commonly used for this purpose, and it even has a single-byte instruction: 0xCC. We could have used any other exception, such as division by zero, but interrupt 3 is the most convenient.</div> <div class=standard  id='magicparlabel-8'>At this point, the process is stopped. If we are debugging this process, the kind kernel gives us the power to play with it - since the process isn't physically running, and is only stored in the kernel's memory, there's nothing stopping us from modifying the registers, memory, etc.</div> <div class=standard  id='magicparlabel-9'>So to set a breakpoint, we just ask the kernel to write an 0xCC in the debugged process's memory, and we continue the process. When the breakpoint is hit, and the process has stopped, we check to see if it's one of our own breakpoints. If it is, we restore the 0xCC to whatever value was sitting there before we set the breakpoint, and continue the process as if nothing happened.</div> <div class=standard  id='magicparlabel-10'>If we want the breakpoint to be hit potentially multiple times, the easiest way would be to use a hardware single-step, and then restore the 0xCC. If you really hate using hardware features, we could have set a burner breakpoint at the next instruction to do a single step, but that would require disassembly of the current instruction (to know where the next instruction even is), and would probably be much slower.</div> <h2 class=section_  id='magicparlabel-11'>ptrace 101</h2> <div class=standard  id='magicparlabel-12'>The way you debug on Linux is with the ptrace system call, and with waitpid (which waits for a process to be stopped).</div> <div class=standard  id='magicparlabel-13'>ptrace returns a <span style='font-family:monospace;'>long</span> and gets <span style='font-family:monospace;'>request, pid, addr, data</span>. Errors are usually represented as -1 and stored in errno. The manpage for ptrace is <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">here</a>, but you could use this as a quick reference:</div> <ul class=itemize  id='magicparlabel-14'><li class=itemize_item ><b>PTRACE_TRACEME</b>: to start tracing a subprocess, rather than attaching to another process in the system, you do the following dance: <div class=highlight ><pre><span></span><span class=kt >pid_t</span> <span class=n >child_pid</span> <span class=o >=</span> <span class=n >fork</span><span class=p >();</span>
<span class=k >if</span> <span class=p >(</span><span class=n >child_pid</span> <span class=o >==</span> <span class=mi >0</span><span class=p >)</span> <span class=p >{</span>
    <span class=n >ptrace</span><span class=p >(</span><span class=n >PTRACE_TRACEME</span><span class=p >,</span> <span class=mi >0</span><span class=p >,</span> <span class=mi >0</span><span class=p >,</span> <span class=mi >0</span><span class=p >);</span>
    <span class=n >execve</span><span class=p >(</span><span class=n >exec_name</span><span class=p >,</span> <span class=n >argv</span><span class=p >,</span> <span class=n >envp</span><span class=p >);</span>
<span class=p >}</span> <span class=k >else</span> <span class=p >{</span>
    <span class=n >waitpid</span><span class=p >(</span><span class=n >child_pid</span><span class=p >,</span> <span class=nb >NULL</span><span class=p >,</span> <span class=mi >0</span><span class=p >);</span>
    <span class=c1 >// we now have the PID of the ptrace&#39;d process, and are attached. the process is stopped</span>
<span class=p >}</span>
</pre></div> <div class=standard  id='magicparlabel-27'>Otherwise, you would use <b>PTRACE_ATTACH</b>, which stops the process and then gives you ptrace access.</div> <li class=itemize_item >In general, playing with the process requires it being stopped. <li class=itemize_item ><b>Memory:</b> <ul class=itemize  id='magicparlabel-30'><li class=itemize_item ><b>PTRACE_PEEKTEXT, PTRACE_PEEKDATA</b>: the return value of ptrace is the <span style='font-family:monospace;'>long</span> at <span style='font-family:monospace;'>addr</span> from the traced process memory. These are equivalent. <li class=itemize_item ><b>PTRACE_POKETEXT, PTRACE_POKEDATA</b>: copies the long which is <span style='font-family:monospace;'>data</span> to <span style='font-family:monospace;'>addr</span> in the process. These are equivalent. <ul class=itemize  id='magicparlabel-32'><li class=itemize_item >We can combine the previous two to put an Interrupt 3 (0xCC): <div class=highlight ><pre><span></span><span class=kt >long</span> <span class=n >data_at_position</span> <span class=o >=</span> <span class=n >ptrace</span><span class=p >(</span><span class=n >PTRACE_PEEKTEXT</span><span class=p >,</span> <span class=n >child_pid</span><span class=p >,</span> <span class=n >breakpoint_position</span><span class=p >,</span> <span class=mi >0</span><span class=p >);</span>
<span class=p >((</span><span class=kt >char</span> <span class=o >*</span><span class=p >)(</span><span class=o >&amp;</span><span class=n >amp</span><span class=p >;</span><span class=n >data_at_position</span><span class=p >))[</span><span class=mi >0</span><span class=p >]</span> <span class=o >=</span> <span class=sc >&#39;\xcc&#39;</span><span class=p >;</span>
<span class=n >ptrace</span><span class=p >(</span><span class=n >PTRACE_POKETEXT</span><span class=p >,</span> <span class=n >child_pid</span><span class=p >,</span> <span class=n >breakpoint_position</span><span class=p >,</span> <span class=n >data_at_position</span><span class=p >);</span>
</pre></div> </ul> </ul> <li class=itemize_item ><b>Registers:</b> <ul class=itemize  id='magicparlabel-41'><li class=itemize_item ><b>PTRACE_GETREGS, PTRACE_SETREGS</b>: <span style='font-family:monospace;'>addr</span> should be the address of a <span style='font-family:monospace;'>user_regs_struct</span>, and the registers are copied/read into the address. </ul> <li class=itemize_item ><b>Continuing the process:</b> <ul class=itemize  id='magicparlabel-43'><li class=itemize_item ><b>PTRACE_CONT</b>: continue the process. If <span style='font-family:monospace;'>data</span> is not zero, it also sends a signal with that number. The next functions use <span style='font-family:monospace;'>data</span> in the same way. <li class=itemize_item ><b>PTRACE_SYSCALL: </b>continue the process, BUT stop at the next entry or exit from a syscall. So you call it once, check if it stopped because of as syscall (it's a SIGTRAP and the instruction 2 bytes before is 0x0f 0x05), and if so you're right before the syscall actually ran. Use PTRACE_SYSCALL again to have it stop after the syscall. <li class=itemize_item ><b>PTRACE_SINGLESTEP: </b>continue the process, BUT stop at the next instruction. <li class=itemize_item ><b>PTRACE_DETACH</b>: if for some reason you're done with the process, you can do that. It continues automatically. <li class=itemize_item >To stop a process, just use the kill syscall. </ul> <li class=itemize_item ><b>Waiting for the process to stop</b>: We use <span style='font-family:monospace;'><a href="https://man7.org/linux/man-pages/man3/wait.3p.html">waitpid</a></span> for that. It blocks until the process stops. <div class=highlight ><pre><span></span><span class=kt >int</span> <span class=n >stat_val</span><span class=p >;</span>
<span class=n >waitpid</span><span class=p >(</span><span class=n >child_pid</span><span class=p >,</span> <span class=o >&amp;</span><span class=n >amp</span><span class=p >;</span><span class=n >stat_val</span><span class=p >,</span> <span class=mi >0</span><span class=p >);</span>
<span class=k >if</span> <span class=p >(</span><span class=n >WIFSTOPPED</span><span class=p >(</span><span class=n >stat_val</span><span class=p >))</span> <span class=p >{</span>  <span class=c1 >// non-zero if process stopped</span>
	<span class=kt >int</span> <span class=n >stop_sig</span> <span class=o >=</span> <span class=n >WSTOPSIG</span><span class=p >(</span><span class=n >stat_val</span><span class=p >);</span>  <span class=c1 >// the signal number that caused the stop</span>
<span class=p >}</span>
</pre></div> <li class=itemize_item >The full list of functions on stat_val is: <table><tr><td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-83'><b>has it happened</b></div> <td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-86'><b>the status code</b></div> <td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-89'><b>explanation</b></div> <tr><td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-92'>WIFEXITED</div> <td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-95'>WEXITSTATUS</div> <td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-98'>process has exited normally</div> <tr><td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-101'>WIFSIGNALED</div> <td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-104'>WTERMSIG</div> <td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-107'>terminated due to uncaught signal</div> <tr><td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-110'>WIFSTOPPED</div> <td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-113'>WSTOPSIG</div> <td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-116'>process has been stopped</div> <tr><td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-119'>WCONTINUED</div> <td align='left' valign='top'> <td align='left' valign='top'> <div class=plain_layout  id='magicparlabel-125'>someone has continued the process</div> </table> </ul> </ul> <div class=standard  id='magicparlabel-126'>There's also PTRACE_SETOPTIONS for extra settings (passed as flags in data) such as making the traced process exit when the debugger exits (PTRACE_O_EXITKILL), stopping before a new process is created (PTRACE_O_TRACECLONE), etc. See the manpage for all the options.</div> <h2 class=section_  id='magicparlabel-127'>Miscallaneous things I had to learn the hard way and you shouldn't</h2> <ul class=itemize  id='magicparlabel-128'><li class=itemize_item >ptrace doesn't like being called from two different threads <li class=itemize_item >the syscall number is stored in orig_rax, not in rax </ul> </article>