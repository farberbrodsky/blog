<!DOCTYPE html><meta charset=utf-8 ><meta name=viewport  content="width=device-width"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital@0;1&display=swap" rel=stylesheet ><title>Anti-Disassembly - how malware obfuscates its code</title><style>@charset "utf-8";html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}table{border-collapse:collapse;border-spacing:0}body{background:#fafafa;font-family:'IBM Plex Serif',serif;font-size:20px}nav{display:flex;background:#171717;color:white;z-index:1;position:relative;align-items:center;justify-content:space-between}nav>div{display:flex}nav h1{margin:0 8px;font-size:28px;line-height:1.6}nav p{margin:0 12px 0 6px}nav h1,nav p{cursor:pointer}nav h1:hover,nav p:hover{text-decoration:underline}nav a{color:inherit;text-decoration:inherit}a{color:#29B6F6}.titledate{text-align:center;background:#222;color:white;padding:32px;margin-bottom:10px;box-shadow:0 0 8px #444}.title,.author{margin-bottom:18px;font-size:22px}.title{font-size:34px}.date{color:gray;font-style:italic}article{padding:32px;line-height:1.3;margin:0 auto;max-width:1200px}h2,h3{font-size:32px;font-weight:bold;padding:32px 0}h3{font-size:24px;padding:16px 0}article .standard{padding:4px 0}table{margin:4px auto}td{padding:4px 6px;border:1px black solid}</style><nav><h1><a href="/">Misha's blog</a></h1><div><p><a href="/articles">Articles</a></p><p><a href="/about">About</a></p></div></nav><div class=titledate ><h1 class=title  id='magicparlabel-1'>Anti-Disassembly - how malware obfuscates its code</h1> <div class=date  id='magicparlabel-2'>July 19, 2021</div> </div class="titledate"><article><div class=standard  id='magicparlabel-3'>Disassemblers are one of the most useful tools when reverse-engineering software. We trust them blindly, but there are many ways they can be deceived. I wrote this article after reading the anti-disassembly chapter in &ldquo;<i>Practical Malware Analysis: The Hands-On Guide to Dissecting Malicious Software&rdquo;</i>, which is a great book and you should totally read it.</div> <h2 class=section_  id='magicparlabel-4'>How do disassemblers work?</h2> <h3 class=subsection_  id='magicparlabel-5'>Linear Disassemblers</h3> <div class=standard  id='magicparlabel-6'>A linear disassembler is simple - it reads an instruction according to the instruction set architecture (which is easy, it's an operation code and some well-defined operands), checks the size of the instruction and just reads the next one. This is intuitive - however, it doesn't really work in this complicated world. Often times, we have jump tables (which are used to optimise switches and contain addresses for every possible value), or other data, which is in the same place as instructions. So a disassembler can't just assume the next few bytes are going to be instructions.</div> <div class=standard  id='magicparlabel-7'>This is where flow-oriented disassemblers come in...</div> <h3 class=subsection_  id='magicparlabel-8'>Flow-oriented disassemblers</h3> <div class=standard  id='magicparlabel-9'>Flow-oriented disassembly is what dedicated products such as IDA Pro or Ghidra use. To disassemble well, we need to know which offsets instructions are at. To do so, we can just look at the jumps - every address mentioned is now marked as an address where assembly starts. This way, when we attempt to disassemble something that isn't assembly, and it overlaps with a place we now is vaild, we will disassemble from there and mark the previous bytes as unknown data. In normal, everyday assembly we now shouldn't get destroyed by the occasional non-code byte.</div> <div class=standard  id='magicparlabel-10'>This is great! However, we have made some big assumptions.</div> <div class=standard  id='magicparlabel-11'>Who said a single byte doesn't belong in two instructions?</div> <h2 class=section_  id='magicparlabel-12'>Breaking the disassemblers</h2> <div class=standard  id='magicparlabel-13'>Let's look at the following example:</div> <div class=standard  id='magicparlabel-14'><table><tr><td align='center' valign='top'> <div class=plain_layout  id='magicparlabel-37'>EB</div> <td align='center' valign='top'> <div class=plain_layout  id='magicparlabel-40'>FF</div> <td align='center' valign='top'> <div class=plain_layout  id='magicparlabel-43'>C0</div> <td align='center' valign='top'> <div class=plain_layout  id='magicparlabel-46'>48</div> <tr><td align='center' valign='top' colspan='2'> <div class=plain_layout  id='magicparlabel-49'>JMP -1</div> <td align='center' valign='top'> <td align='center' valign='top'> <div class=plain_layout  id='magicparlabel-58'>DEC EAX</div> <tr><td align='center' valign='top'> <td align='center' valign='top' colspan='2'> <div class=plain_layout  id='magicparlabel-64'>INC EAX</div> <td align='center' valign='top'> </table> </div> <div class=standard  id='magicparlabel-71'>The processor reads it as jumping back to the address where FF is, then incrementing and decreasing EAX. This is useless and can be inserted pretty much anywhere like a NOP is. A disassembler will obviously get confused - linearly, it doesn't make sense (C0 48 is some sort of ROR instruction), and flow-based, the 0 offset is legal, and the 1 offset is legal too, but they are overlapping, so RIP disassembler.</div> <div class=standard  id='magicparlabel-72'>The only way to mitigate this kind of anti-disassembly is to look for all of these sequences and convert them to something that is understandable - in this case, just convert it to a NOP.</div> <div class=standard  id='magicparlabel-73'>There are many other examples - we can XOR EAX, EAX, then JZ to some legal instruction, and leave a rogue byte to ruin the disassembly. JZ means that both the position after the jump and the next instruction are legal, again confusing the disassembler. These must be taken care of manually. Solving such problems is hard - they can obviously be made far more complicated and even contain some real logic.</div> <div class=standard  id='magicparlabel-74'>Additionaly, using the same XOR EAX, EAX then JZ technique (or something else that is definitely true), we can add a JMP that never happens, and mark any other place as code.</div> <h2 class=section_  id='magicparlabel-75'>Higher-level ways to make life difficult for analysers</h2> <div class=standard  id='magicparlabel-76'>Compiled code usually follows very simple patterns - functions are called with CALL which pushes the instruction pointer then jumps, and functions start with push EBP and end with a pop EBP and a RET (which does the opposite of CALL - pop into the old instruction pointer). This makes life easy for us, but it's not rigid. Nothing prevents you from pushing a pointer then doing a RET. In static analysis, a disassembler doesn't know this is functionally equivalent to jumping. You could even obfuscate it further by doing arithmetic on an address which is relative to EBP, but actually ends up being the address of ESP, which takes a lot of time to understand as an analyser.</div> </article>