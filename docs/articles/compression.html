<!DOCTYPE html><meta charset=utf-8 ><meta name=viewport  content="width=device-width,initial-scale=1"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital@0;1&display=swap" rel=stylesheet ><title>Lossless compression - how ZIP makes files smaller</title><style>@charset "utf-8";html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}table{border-collapse:collapse;border-spacing:0}body{background:#fafafa;font-family:'IBM Plex Serif',serif;font-size:20px}nav{display:flex;background:#171717;color:white;z-index:1;position:relative;align-items:center;justify-content:space-between}nav>div{display:flex}nav h1{margin:0 8px;font-size:28px;line-height:1.6}nav p{margin:0 12px 0 6px}nav h1,nav p{cursor:pointer}nav h1:hover,nav p:hover{text-decoration:underline}nav a{color:inherit;text-decoration:inherit}a{color:#29B6F6}.titledate{text-align:center;background:#222;color:white;padding:32px;margin-bottom:10px;box-shadow:0 0 8px #444}.title,.author{margin-bottom:18px;font-size:22px}.title{font-size:34px}.date{color:gray;font-style:italic}article{padding:32px;line-height:1.3;margin:0 auto;max-width:1200px}@media only screen and (max-width:700px){article{padding:12px}}h2,h3{font-size:32px;font-weight:bold;padding:32px 0}h3{font-size:24px;padding:16px 0}article .standard{padding:4px 0}table{margin:4px auto}td{padding:4px 6px;border:1px black solid}ul{list-style-type:disc}ol{list-style-type:decimal}ul ul,ul ol,ol ol,ol ul{padding-left:32px}li::before{content:"";display:inline-block;width:8px}</style><nav><h1><a href="/">Misha's blog</a></h1><div><p><a href="/articles">Articles</a></p><p><a href="/about">About</a></p></div></nav><div class=titledate ><h1 class=title  id='magicparlabel-1'>Lossless compression - how ZIP makes files smaller</h1> <div class=date  id='magicparlabel-2'>July 23, 2021</div> </div class="titledate"><article><div class=standard  id='magicparlabel-3'>ZIPs use Deflate by default, which was invented for this purpose in the 90s. To make files smaller, deflate uses <i>huffman trees</i> and <i>Lempel-Ziv</i>.</div> <div class=standard  id='magicparlabel-4'>Deflate is described in <a href="https://datatracker.ietf.org/doc/html/rfc1951">RFC1951</a>. I've actually written a <a href="https://github.com/farberbrodsky/c-deflate/blob/main/decompressor.c">decompressor</a> for it in C, which is riddled with bugs (I tried fuzzing it and I was mortified).</div> <div class=standard  id='magicparlabel-5'>We'll first look at huffman trees and Lempel-Ziv theoretically, and then I'll describe how deflate uses them. This article will give you a general overview, but if you want to write a decompressor, you'd still need to read the RFC.</div> <h2 class=section_  id='magicparlabel-6'>Huffman trees</h2> <div class=standard  id='magicparlabel-7'>In regular text, every character takes exactly 8 bits. This is awful - people rarely use the letter q, but it takes just as much space to write a q as it does to write an a, e, i, o or u. If we know what we're gonna write, and thus how frequent every letter is, we can create an code where a, e, i, o and u have <i>less bits</i> than q.</div> <div class=standard  id='magicparlabel-8'>However, this presents some issues - what if a is 0, b is 10, and c is 100? Then, we could read c as ba. Our code must be <i>prefix-free</i>, which means no character starts with another character. In a prefix-free code, when we read 10, we can immediately say that is 'b', which also makes decoding much faster.</div> <div class=standard  id='magicparlabel-9'>A prefix-free code can be drawn as a tree:</div> <div class=standard  style='text-align: center;' id='magicparlabel-10'><img src='/home/runner/work/blog/blog/assets/compression-huffman-1.svg' alt='image: ' /> </div> <div class=standard  id='magicparlabel-11'>If a code is prefix-free, then it <i>must</i> be representable as a tree where only leaves have letters. The encoding of b is 1-0, because we first go right then left to get to it. To decode, we simply read a bit and then go accordingly on the tree. To encode, we'd have a table of letter to encoding.</div> <div class=standard  id='magicparlabel-12'>To create a huffman tree by frequencies, the algorithm is as following:</div> <ol class=enumerate  id='magicparlabel-13'><li class=enumerate_item >Create a tree leaf for every character. <li class=enumerate_item >Take the two lowest frequencies, and make a tree out of them, that is, () -&gt; (a, b). The frequency of this is the sum of the frequencies of a, b. <li class=enumerate_item >Repeat step 2, until there is a single tree. <li class=enumerate_item >Profit. Your single tree is the most efficient prefix-free code. </ol> <div class=standard  id='magicparlabel-17'>This alone can achieve great compression in everyday text - before a long article, you put the huffman tree for it. Then, characters that aren't used can't even be represented, and if we use A all the time it takes less bits.</div> <div class=standard  id='magicparlabel-18'>I've been saying &ldquo;huffman tree&rdquo; a lot though. How can we make repetitions take less space?</div> <h2 class=section_  id='magicparlabel-19'>Lempel-Ziv</h2> <div class=standard  id='magicparlabel-20'>Real text often repeats repeats itself. Let's say our text is &ldquo;Hello Anne, hello Andrew!&rdquo;. We have a repetition here - &ldquo;H(ello An)ne, h(ello An)drew!&rdquo;. We could represent this as &ldquo;Hello Anne, h&lt;12,7&gt;drew!&rdquo;, where 12 is how many bytes back to go, and 7 is how many bytes to write. Additionally, length may be larger than the offset - for example &ldquo;AAAAAAAA&rdquo; can be represented as &ldquo;A&lt;1,7&gt;&rdquo;. The decompressor would go 1 byte back, and copy 7 bytes to the next byte.</div> <div class=standard  id='magicparlabel-21'>To find repetitions efficiently, you can use <a href="https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm">this algorithm</a>, but it's outside the scope of this article.</div> <h2 class=section_  id='magicparlabel-22'>Using <i>both of them</i> to create Deflate</h2> <div class=standard  id='magicparlabel-23'>A deflate file is built out of blocks. Every block comes with 3 bits of metadata - 1 bit that says whether this is the last block, and 2 bits that say what kind of block it is.</div> <div class=standard  id='magicparlabel-24'>00 - no compression, 01 - fixed Huffman codes, 10 - dynamic Huffman codes, 11 - invalid, error.</div> <div class=standard  id='magicparlabel-25'>A 00 block starts with the length of the block and is used to make sure Deflated files are never more than a few percents larger than uncompressed data. A 01 block does not come with a Huffman code but has a good-enough code included in the RFC, and a 10 block starts with a Huffman tree. The way the huffman tree in a 10 block is encoded is hard to implement, and if you want to implement it you should read the RFC.</div> <div class=standard  id='magicparlabel-26'>A problem with encoding Lempel-Ziv in binary is that you need to have a way to store repetitions in the middle of text, and know whether it's a repetition or text. That's why in our Huffman tree, we actually have more than 256 different values:</div> <ol class=enumerate  id='magicparlabel-27'><li class=enumerate_item >0-255: literal bytes <li class=enumerate_item >256: end of block (if you see this in the code, you move on to the next block in Deflate) <li class=enumerate_item >257-285: length codes, of varying lengths, shown <a href="https://datatracker.ietf.org/doc/html/rfc1951#page-12">here</a>. There are a few extra bits for length. </ol> <div class=standard  id='magicparlabel-30'>After the length code, we have a huffman tree for distances, which works similarly - it has codes 0-29, each of which is for a different range of distances, and extra bits.</div> <div class=standard  id='magicparlabel-31'>And that pretty much sums up Deflate - you have blocks, some of which include a Huffman tree and some of which don't, and to decompress you read the next code according to your Huffman tree, and must store in memory the last 32768 bytes written (maximum distance of repetition). You get both the benefits of Huffman and of Lempel-Ziv: characters used more often take less bits according to your tree, and repetitions are encoded so efficiently, that even a 3-byte repetition can save you some space.</div> </article>